--------------------------

学籍番号 : 16B16163
氏名 : 吉川純平

--------------------------

回答1 :
1.1) 途中結果が表示されなかった理由の説明
operation()とwritestate()はJavaFX Application Threadで呼び出されているが、その場合、JavaFx Application Threadが終了せず、
label.setText(state)が計算途中に実行できないから。


1.2) 改良方針の説明
"="ボタンのクリックイベントを引き金にしてスレッドを生成し、実行して、そのスレッドの中で
operation()とwritestate()を実行している。



1.3) 発生したエラー文は次のとおり
Exception in thread "Thread-3" java.lang.IllegalStateException: Not on FX application thread; currentThread = Thread-3




runLater()の処理内容について
labelの文字をstateに指定し、計算過程を出力するようにしている。



runLater()がjavafxに用意されている理由
アプリケーションが応答しなくなる可能性があるのでアプリケーションが、多すぎる保留中RunnableをJavaFXに送らないようにする必要がある。
長い計算過程の途中を出力するためには操作は可能な場合はバックグラウンド・スレッドで実行しするのがよく、
GUI操作のためにJavaFXアプリケーション・スレッドを解放する必要があるが、label.setText(state)はJavaFx Application Thread
で実行される必要があるから適切なタイミングでJavaFx Application Threadが実行してくれるrunLater()は必要である。




回答2 :
2.2)2つのスレッドのそれぞれの処理内容について
1つ目のスレッド
main
受け付けたデータを表示するウィンドウの初期化をする。
受付け用ソケットを開き、受信データの格納場所を用意し受信したデータの格納をする。



2つ目のスレッド
Thread-3
受信データを表示する。


2.3)同期についての考えられている配慮

不十分である


不十分であると考える場合の問題となる具体的状況
smsの配列の要素数は３であり、クライアントが計４つ以上接続すると、同じsmsを使うことになり、新しいクライアントのsmsには
古いクライアントのsmsが同じものであり、既に図形が出力されてしまっているから。





2.4)並行サーバを実現するにあたり工夫した点
各クライアントからのデータの表示位置の割り振りについてどのように実現したかなど
３要素分のスレッドプールを用意し、４つ目のクライアントの接続要求が来たとき、待機させ、
一つのスレッドが終了したらそのスレッドに割り当てる。
それぞれのサーバとの接続状況をkeepの変数でとった。




回答3 :
3.1)改造方針、スレッドの役割分担についての説明
targetを二つ用意し、図形描写用とサーバーのウィンドウに出力する用に分けて実装した。
thread-3は受信データをサーバーのウィンドウ表示だけでなく、クライアントへの送信を実装した。





回答4 :
4.1)
PrintStreamでの例外発生を確認する方法
ps.checkError()




例外処理がPrintStreamと他のStreamとで異なる理由
System.outやSystem.errはPrintStreamのインスタンスであり、Systemを使った時に毎回try-catchするのは実用的でないから。



4.2)
受信機能の追加について、工夫した点があれば記述






今回の課題で特に学べたと感じたこと
Threadは便利であるが、バグの特定が難しいこと。
